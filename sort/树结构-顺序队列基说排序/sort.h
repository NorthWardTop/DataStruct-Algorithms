#pragma once

#include <iostream>
#include <stdlib.h>
#include <windows.h>
#pragma comment(lib,"winmm.lib")

#define LEN 100
using namespace std;
/*
内存:
	普通函数调用, 保存原调函数位置保存在环境栈
	递归函数参数和局部变量临时保存在环境栈
	引用参数也保存在环境栈

*/

/*
选择排序:一个数和一堆无序数比较
*/

/*
插入排序:
	思想:将后面无序几何逐一插入前面有序集合(一个数和一堆已序数比较)
	普通算法:有序和当前值一直比较,当前值向前交换
		(当前值从1开始,有序值从有序尾开始)
	优化算法:也是有序和当前一直比较,只是将大于的有序值后移,
		为当前值让位,相当于于数组插入,只最后插入一次,
		其他动作都在后移小与有序的当前值
*/
void printArr(int a[], int len)
{
	for (int i = 0; i < len; ++i)
	{
		cout << a[i] << "	";
	}
	cout << "\n#############################################\
################################################\n";
	char* icon[5];
	char chCtrl = 97;
	char clr[20];
	icon[0]="    ___  __ _______________  __  _____  ___  ________  ___";
	icon[1]="   / _ \\/ // /  _/ ___/ __ \\/  |/  /  |/  / / __/ __ \\/ _ \\ ";
	icon[2]="  / ___/ _  // // /__/ /_/ / /|_/ / /|_/ / _\\ \\/ /_/ / ___/";
	icon[3]=" /_/  /_//_/___/\\___/\\____/_/  /_/_/  /_/ /___/\\____/_/";
	icon[4]=" ----------------------------------------------------------";
	for (int i = 0; i < 5; i++)
	{
		sprintf(clr, "color 0%c", chCtrl);
		cout << icon[i] << endl;
		chCtrl++;
	//	Sleep(1000);
		system(clr);
	}
	cout << endl;
}

/*
    ___  __ _______________  __  _____  ___  ________  ___
   / _ \/ // /  _/ ___/ __ \/  |/  /  |/  / / __/ __ \/ _ \
  / ___/ _  // // /__/ /_/ / /|_/ / /|_/ / _\ \/ /_/ / ___/
 /_/  /_//_/___/\___/\____/_/  /_/_/  /_/ /___/\____/_/

*/

void insertSort(int a[], int len)
{	
	////1.普通算法
	////从1循环到n-1,因为元素0认为有序数列, 所以从1开始
	//for (int i = 1; i < len; ++i)
	//{	//内层循环已序,寻找插入位置,从已序最大开始,直到j为负数
	//	for (int j = i - 1; j >= 0; --j)
	//	{	//已序元素>无序元素,交换
	//		if (a[j+1]<a[j])
	//		{
	//			int tmp = a[j+1];
	//			a[j + 1] = a[j];
	//			a[j] = tmp;
	//		}
	//		else  //不大于无需操作,后一个元素直接加入已序
	//			break;
	//	}
	//}

	//2.优化算法
	int j, tmpVal;
	for (int i = 1; i < len; ++i)
	{
		tmpVal = a[i];	//保存当前待排序的数
		j = i - 1;
		while (j >= 0 && a[j]>tmpVal)	//当有序中值比当前值大
		{	//一直给当前值让位,直到不大于,当前值就应该在这
			a[j + 1] = a[j];	//前面值大将大值值后移
			j--;
		}
		a[j+1] = tmpVal;	//将当前值放 入最后一次交换的地方
	}
}

/*
shell排序:
	思想:第一组最小和第一组最小比较取下最小,将取下的下标后移
		(用两堆有序数来排序,永远用两个最小的数比较,减少移动)
*/

void shellSort(int a[], int len)
{
	int tmpVal, j;
	int jump = len >> 1;	//最初步长为长度一半
	while (jump != 0)
	{
		//每轮内部是插入算法,
		for (int i = 1; i < len; ++i)
		{
			tmpVal = a[i];	//保存当前待排序的数
			j = i - jump;	///变化:减去步长,和上个步长比较
			while (j >= 0 && a[j]>tmpVal)	//当有序中值比当前值大
			{	//一直给当前值让位,直到不大于,当前值就应该在这
				//变化:加上步长,后移一个步长
				a[j + jump] = a[j];	//前面值大将大值值后移
				j-=jump;	//变化:指向变化一个步长
			}
			//变化:
			a[j + jump] = tmpVal;	//将当前值放入最后一次交换的地方
		}
		jump = jump >> 1;	//每轮循环完成,步长折半
	}

}

/*
基数排序:对于整数排序效率很高
方法:d进制整数有d个桶从0到d-1,
	(第一轮)将每个数最低位对d取余放入对应桶,
	将数据从桶中按顺序取出
	(第二轮)将每个数的次低位对d取余放入桶
	...
步骤:
每一轮(轮间n*=10)
	1.初始化一个临时二维数组,保存d个桶
	2.按规定(a[i] / n) % 10放入对应的桶
	3.从桶中取出放回数组
	注:最大级别n为最大数级别
*/
void radixSort(int a[], int len)
{
	//从1开始除以n(1-10-100...),每一轮除以不同的级数
	for (int n = 1; n <= 10000; n *= 10)
	{
		//临时数组,d个桶,每个桶可放LEN个数据
		int temp[10][LEN] = {};
		//初始化临时数组
		for (int i = 0; i < 10; ++i)
		{
			for (int j = 0; j < LEN; ++j)
			{
				temp[i][j] = -1;
			}
		}
		for (int i = 0; i < len; ++i)
		{
			//每个数除以n得到第最低几位在取余
			//算得该放哪一个桶
			int m = (a[i] / n) % 10;
			//放进第m桶
			temp[m][i] = a[i];
		}
		int k = 0;
		//不为-1就空值,放数据
		for (int i = 0; i < 10; ++i)
		{
			for (int j = 0; j < LEN; ++j)
			{
				if (temp[i][j]!=-1)
					a[k++] = temp[i][j];
			}
		}
	}
}


/*
归并排序
思想:
*/